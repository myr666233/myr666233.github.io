<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>jvm读书笔记（一） | 莫逸然的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="jvm读书笔记之（一） 一、jvm内存区域 1、程序计数器 简要的来说，字节码解释器工作时通过改变这个计数器的指来选择下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等。如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码指令的地址、如果是native方法，这个计数器值为空。 2、java虚拟机栈 java虚拟栈是线程私有的，与线程是一样的生命周期。方法在执行时会">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm读书笔记（一）">
<meta property="og:url" content="http://myr666233.github.io/2020/04/13/jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="莫逸然的博客">
<meta property="og:description" content="jvm读书笔记之（一） 一、jvm内存区域 1、程序计数器 简要的来说，字节码解释器工作时通过改变这个计数器的指来选择下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等。如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码指令的地址、如果是native方法，这个计数器值为空。 2、java虚拟机栈 java虚拟栈是线程私有的，与线程是一样的生命周期。方法在执行时会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/22823288-5f9c32cdbe61eba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/22823288-335bd9eece95210d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/22823288-0ead8cb42d191784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2020-04-13T08:54:31.000Z">
<meta property="article:modified_time" content="2020-04-13T09:09:36.811Z">
<meta property="article:author" content="莫逸然">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/22823288-5f9c32cdbe61eba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="莫逸然的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">莫逸然的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://myr666233.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-jvm读书笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/13/jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-04-13T08:54:31.000Z" itemprop="datePublished">2020-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      jvm读书笔记（一）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jvm读书笔记之（一）</p>
<p>一、jvm内存区域</p>
<p>1、程序计数器</p>
<p>简要的来说，字节码解释器工作时通过改变这个计数器的指来选择下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等。如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码指令的地址、如果是native方法，这个计数器值为空。</p>
<p>2、java虚拟机栈</p>
<p>java虚拟栈是线程私有的，与线程是一样的生命周期。方法在执行时会创建一个栈帧，存储局部变量表、操作数块、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、int等等）、对象引用。</p>
<p>3、本地方法栈</p>
<p>与虚拟机栈不同的是，虚拟机栈是为执行java方法服务，本地方法栈是为执行native方法服务。不同虚拟机对本地方法栈的实现不同，如sun公司的HotSpot虚拟机将虚拟机栈和本地方法栈合二为一。</p>
<p>4、java堆</p>
<p>堆是被所有线程共享的一款内存区域，几乎所有的对象实例都在堆上分配内存（栈上分配、标量替换则不一定）。</p>
<p>5、方法区</p>
<p>方法区是被所有线程共享的一块内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。方法区不是堆，java虚拟机规范只是把其描述为堆的一个逻辑部分，应当与堆区分开。</p>
<p>HotSpot虚拟机在jdk1.7之前使用永久代来实现方法区，将GC分代收集扩展至方法区，可以向管理堆一样管理方法区，但是容易遇到内存溢出的问题，jdk1.8开始使用Metaspace代替永久代。</p>
<p>注：Metaspace所占用的内存不在虚拟机内，而是在本地内存中。</p>
<p>6、运行时常量池</p>
<p>jdk1.7中，运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容会在类加载后进入运行时常量池中存放。</p>
<p>7、直接内存</p>
<p>不属于虚拟机内存，但是也被频繁的使用，也可能导致OutOfMemoryError异常</p>
<p>二、垃圾收集器与内存分配策略</p>
<p>1、引用计数法</p>
<p>在对象中添加一个引用计数器，每有一个地方引用它，计数器值加1，引用失效时，计数器值减1，计数器值为0，对象可以被回收。但是难以解决循环引用的方式。</p>
<p>2、可达性分析算法</p>
<p>Jvm采用的就是此算法。从GC Roots对象开始向下搜索，如果GC Roots节点到这个对象不可达，则为可回收的对象。</p>
<p>GC Roots对象包括以下几种:</p>
<p>1、虚拟机栈（栈帧中的本地变量表）中引用的对象。</p>
<p>2、方法区中类静态属性引用的对象。</p>
<p>3、方法区中常量引用的对象。</p>
<p>4、本地方法栈中native方法引用的对象。</p>
<p>3、引用类型的详细分类</p>
<p>从强到弱依次是强、软、弱、虚。</p>
<p>1、强引用（Strong Reference）:代码中普遍存在的，如Object o = new Object()，只要引用还存在，就不会被    回收。</p>
<p>2、软引用（Soft Reference）:有用但并非必须的对象，在jvm即将发生内存溢出时，这些对象将被回收。jdk中提供    了SoftReference类来实现软引用。</p>
<p>3、弱引用（Weak Reference）:也是非必须的对象，但是强度弱于软引用。被其关联的对象只能活到下次垃圾回收发    生之前。jdk提供了WeakReference类来实现弱引用。</p>
<p>4、虚引用（Phantom Reference）：最弱的一种引用，为一个对象设置虚引用，只是为了能在这个对象被回收时收    到一个系统通知。jdk提供了PhantomReference类实现虚引用。</p>
<p>4、finalize()方法</p>
<p>对象被回收时会调用finalize()方法，如果在其中自救，重新获得引用，就不会被回收。但是每个对象的finalize()方法    只会调用一次，下次被回收时自救就没用了。</p>
<p>5、方法区的回收</p>
<p>java虚拟机规范中表示不要求虚拟机在方法区实现垃圾回收，而且方法区进行垃圾回收的性价比低。在堆的新生代中，一次垃圾回收可以回收70%~95%的内存。尽管这样，还是有方法区的垃圾回收存在。</p>
<p>jdk1.7的HotSpot虚拟机中，永久代的垃圾回收主要回收俩部分：废弃常量和无用的类。没有String对象引用常量池中的常量，这个常量就可以被回收。而一个类是无用的类，需要同时满足下面3个条件：</p>
<p>1、该类所有的实例都被回收，即堆中不存在该类的任何实例。</p>
<p>2、加载该类的ClassLoader已经被回收。</p>
<p>3、该类的Class对象没有被在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>满足这三种条件，这个类才可以被回收，但是不一定就会被回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。在大量使用反射、动态代理、cglib，动态生成Jsp已经OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，来保证永久代不会溢出</p>
<p>6、垃圾回收算法</p>
<p>6.1、标记-清除算法</p>
<p>算法分为”标记“和”清除”俩个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收。这是最基础的收集算法，其他算法都是基于这种思路进行改进的。它的不足主要有俩个：一是效率问题，标记和清除的效率都不高；二是空间问题，标记清除后会产生大量不连续的内存碎片，这会导致以后如果出现需要分配大内存的对象，会因为无法找到足够的连续内存，再触发另一次垃圾回收。执行过程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/22823288-5f9c32cdbe61eba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>6.2、复制算法</p>
<p>将内存分为俩块，每次只使用其中一块，但这块内存用完了，就将还存活着的对象复制到另一块上，然后把使用的这块内存一次清理。这样不用考虑内存碎片等复杂情况，提升了效率，实现简单。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/22823288-335bd9eece95210d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>堆内存的分配比例：</p>
<p>将新生代的内存分为8：1：1，即eden区占80%，俩块survivor区各占10%。（新生代是指对象刚创建时进入的堆内存的一部分）</p>
<p>每次只使用eden区和一块survivor区，可以使用的内存为90%，只浪费了10%。研究表明新生代的对象98%都是“朝生夕死”，每次只要将eden和survivor区中存活的对象复制到另一块survivor区上，然后清理eden和使用过的那块survivor，因为98%的新生对象都基本上是垃圾了，所以这10%才能装的下。但是也不一定的，总会出现一些特殊的情况，如果survivor空间也不够的话，就要依赖老年代了。（老年代也是堆内存的一部分）</p>
<p>6.3、标记-整理算法</p>
<p>过程与标记清除算法一样，但是不是对可以回收的对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端的边界以外的内存。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/22823288-0ead8cb42d191784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>6.4、分代收集</p>
<p>新生代和老年代根据对象存活周期的不同使用不同的收集算法：新生代一般选用复制算法，老年代使用标记清除或者标记整理算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://myr666233.github.io/2020/04/13/jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ck8y9ab4t0000okux5encck5u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 10px;">JVM</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/13/jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">jvm读书笔记（一）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 莫逸然<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>